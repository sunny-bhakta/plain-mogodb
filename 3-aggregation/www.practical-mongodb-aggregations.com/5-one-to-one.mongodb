/*
* Scenario:
* You want to generate a report listing all shop purchases made in 2020. 
* For each order, display the product's name and category instead of just the product's id. 
* To achieve this, join each order in the customer orders collection with its corresponding product in the products collection. 
* Each order references a product by its id, creating a one-to-one relationship for the join.
*
* Goal:
* Create a report that shows, for every order placed in 2020, the product name and category.
*
* Approach:
* 1. Use $match to filter orders to only those placed in 2020.
* 2. Use $lookup to join each order with its corresponding product using product_id and id fields.
* 3. Use $addFields to flatten the joined product array to a single object.
* 4. Use $addFields to add product name and category fields directly to the order.
* 5. Use $project to exclude unnecessary fields from the output.
*/

db = db.getSiblingDB("testdb");
db.dropDatabase();

use("testdb");

// Create index on 'id' field in products collection for efficient lookup
db.products.createIndex({ id: 1 });

// Insert sample product records
db.products.insertMany([
  {
    id: "a1b2c3d4",
    name: "Asus Laptop",
    category: "ELECTRONICS",
    description: "Good value laptop for students"
  },
  {
    id: "z9y8x7w6",
    name: "The Day Of The Triffids",
    category: "BOOKS",
    description: "Classic post-apocalyptic novel"
  },
  {
    id: "ff11gg22hh33",
    name: "Morphy Richardds Food Mixer",
    category: "KITCHENWARE",
    description: "Luxury mixer turning good cakes into great"
  },
  {
    id: "pqr678st",
    name: "Karcher Hose Set",
    category: "GARDEN",
    description: "Hose + nozzles + winder for tidy storage"
  }
]);

// Create index on 'orderdate' in orders collection for efficient date filtering
db.orders.createIndex({ orderdate: -1 });

// Insert sample order records
db.orders.insertMany([
  {
    customer_id: "elise_smith@myemail.com",
    orderdate: ISODate("2020-05-30T08:35:52Z"),
    product_id: "a1b2c3d4",
    value: NumberDecimal("431.43")
  },
  {
    customer_id: "tj@wheresmyemail.com",
    orderdate: ISODate("2019-05-28T19:13:32Z"),
    product_id: "z9y8x7w6",
    value: NumberDecimal("5.01")
  },
  {
    customer_id: "oranieri@warmmail.com",
    orderdate: ISODate("2020-01-01T08:25:37Z"),
    product_id: "ff11gg22hh33",
    value: NumberDecimal("63.13")
  },
  {
    customer_id: "jjones@tepidmail.com",
    orderdate: ISODate("2020-12-26T08:55:46Z"),
    product_id: "a1b2c3d4",
    value: NumberDecimal("429.65")
  }
]);

// Aggregation pipeline to join orders with product details and filter for 2020
const pipeline = [
  // 1. Filter orders to only those placed in 2020
  {
    $match: {
      orderdate: {
        $gte: ISODate("2020-01-01T00:00:00Z"),
        $lt: ISODate("2021-01-01T00:00:00Z")
      }
    }
  },
  // 2. Join each order with its corresponding product using $lookup
  {
    $lookup: {
      from: "products",
      localField: "product_id",
      foreignField: "id",
      as: "product_info"
    }
  },
  // 3. Flatten the joined product array to a single object
  {
    $addFields: {
      product_info: { $arrayElemAt: ["$product_info", 0] }
    }
  },
  // 4. Add product name and category fields directly to the order
  {
    $addFields: {
      product_name: "$product_info.name",
      product_category: "$product_info.category"
    }
  },
  // 5. Remove unnecessary fields from the output
  {
    $project: {
      product_info: 0,
      product_id: 0,
      _id: 0
    }
  }
];

// Execute the aggregation and return the results as an array
const result = db.orders.aggregate(pipeline).toArray();
result;
