// Scenario:
// Query a collection of persons where each document contains one or more languages spoken.
// The result should be an alphabetically sorted list of unique languages for a UI drop-down.

db = db.getSiblingDB("testdb");
db.dropDatabase();

use("testdb");

// Insert records into the persons collection
db.persons.insertMany([
  { firstname: "Elise", lastname: "Smith", vocation: "ENGINEER", language: "English" },
  { firstname: "Olive", lastname: "Ranieri", vocation: "ENGINEER", language: ["Italian", "English"] },
  { firstname: "Toni", lastname: "Jones", vocation: "POLITICIAN", language: ["English", "Welsh"] },
  { firstname: "Bert", lastname: "Gooding", vocation: "FLORIST", language: "English" },
  { firstname: "Sophie", lastname: "Celements", vocation: "ENGINEER", language: ["Gaelic", "English"] },
  { firstname: "Carl", lastname: "Simmons", vocation: "ENGINEER", language: "English" },
  { firstname: "Diego", lastname: "Lopez", vocation: "CHEF", language: "Spanish" },
  { firstname: "Helmut", lastname: "Schneider", vocation: "NURSE", language: "German" },
  { firstname: "Valerie", lastname: "Dubois", vocation: "SCIENTIST", language: "French" },
]);

// Aggregation pipeline to get unique, sorted languages
const pipeline = [
  // Ensure 'language' is always an array
  { $addFields: { language: { $cond: [{ $isArray: "$language" }, "$language", ["$language"] ] } } },
  // Unwind the 'language' array
  { $unwind: "$language" },
  // Group by language to get distinct values
  { $group: { _id: "$language" } },
  // Sort languages alphabetically
  { $sort: { _id: 1 } },
  // Rename _id to language and remove _id field
  { $project: { language: "$_id", _id: 0 } }
];

db.persons.aggregate(pipeline);
